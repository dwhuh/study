# Async & Await
비동기 코드를 처리하기 위해 사용되는 새로운 방법

<br>

## Async & Await을 사용하는 이유
기존 프로미스의 방식에서 콜백으로 비동기 처리를 하지 않고  
프로미스의 결과 값을 변수에 담아 사용할 수 있는 장점이 있습니다.  
```async & await```은 외관상 비동기 코드를 동기 코드로 작성할 수 있습니다.  
또한, 문법이 간결하고 에러 핸들링이 쉽기 때문입니다.

<br>

## 사용방법
함수 앞에 ```async``` 키워드가 오게하는데 이는 반환되는 값을 프로미스로 하겠다는 선언입니다.  
기다릴 프로미스 객체 앞에 ```await``` 키워드를 사용하여 함수의 동작을 일시중지하여 ```resolve``` 된 데이터를 변수에 담아 사용할 수 있습니다.

<br>

## 왜 Async & Await 인가?
* **간결함과 깔끔함**  
  프로미스를 사용하던 때의 코드량이 확연히 줄어들고,  
  ```response```를 해결하기 위한 함수콜을 사용하지 않아도 됩니다.  
  또한 ```nesting(중첩/콜백지옥)```을 해결할 수 있습니다.
* **에러 핸들링**  
  ```try/catch```를 이용한 에러 핸들링이 가능하며 보다 명확한 방법을 제시할 수 있습니다.  
  프로미스에서는 내부에 ```try/catch```가 동작하지 않으며, ```catch``` 메소드로 핸들링이 가능합니다.  
  하지만 ```catch``` 메소드를 이용한 에러 핸들링은 코드가 중복될 경우가 있는 단점이 있습니다.
* **분기**  
  프로미스로 콜백지옥을 어느정도 해결할 수 있다하지만  
  조건문에 따라 다른 프로미스 결과를 가져오는 코드를 작성한다면 여러번의 중첩이 발생하여 다시 콜백 지옥에 빠지게 될 수 있습니다.  
  ```async & await```은 이러한 문제를 해결할 수 있으며 가독성 또한 높여주는 효과를 얻을 수 있습니다.
* **Error Stack**  
  프로미스 체이닝을 이용한 비동기 처리를 에러가 발생한 시점을 정확히 파악할 수 없지만,  
  ```async & await```을 사용하면 에러가 발생한 시점을 정확히 파악할 수 있습니다.
* **디버깅**  
  ```await``` 되는 부분을 ```break point```를 찍어 확인할 수 있는 장점이 있습니다.
